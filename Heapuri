#include <bits/stdc++.h>
using namespace std;
const int MAX = 200005;
int N, quest, node, nh, values[MAX], heap[MAX], pos[MAX];  //difference between values and the heap itself?
bool comp(int, int);
void swapX(int, int);
void upHeap(int);
void downHeap(int);
void addNode(int);
void delNode(int);
void solve();
int main(){
    solve();
    return 0;
}
bool comp(int x, int y){
    return values[x] < values[y];
}
void swapX(int child, int parent){  //essentially you will have to switch children and parents
    swap(heap[child], heap[parent]);
    swap(pos[heap[child]], pos[heap[parent]]);
}
void upHeap(int child){
    int parent = child >> 1;         //divided by 2, only that it's divided binary
    bool var = comp(heap[child], heap[parent]); // Min Heap property(child's value is less than father's value)
    if((parent >= heap[1]) and var){ // Why parent?
        swapX(child,parent);         //swap the position and the value itself
        upHeap(parent);
    }
}
void downHeap(int parent){
    int child = parent << 1;
    bool var = comp(heap[child + 1], heap[child]);
    bool var2 = child + 1 <= nh;
    child = child + (var and var2);
    bool var3 = comp(heap[child], heap[parent]);
    if(child <= nh and var3){
        swapX(parent, child);
        downHeap(child);
    }
}
void addNode(int node){
    ++nh;
    heap[nh] = node;
    pos[node] = nh;
    upHeap(pos[node]); //If you just type node, il will fail and reach 0 points.
}
void delNode(int node){
    swapX(node, nh);
    pos[heap[nh]] = 0;
    heap[nh] = 0;
    nh--;
    downHeap(node);
}
void solve(){
    ifstream f("heapuri.in");
    ofstream g("heapuri.out");
    f >> N;
    for(int i = 0; i < N; ++i){
        f >> quest;
        switch(quest){
        case 1:
            ++node;
            f >> values[node];
            addNode(node);
            break;
        case 2:
            f >> quest;
            delNode(pos[quest]);
            break;
        case 3:
            g << values[heap[1]] << "\n"; //value of the root
        }
    }
}
